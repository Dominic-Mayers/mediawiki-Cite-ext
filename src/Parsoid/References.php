<?php // lint >= 99.9
// phpcs:ignoreFile
// phpcs:disable Generic.Files.LineLength.TooLong
/* REMOVE THIS COMMENT AFTER PORTING */
namespace Parsoid;

$ParsoidExtApi = $module->parent->parent->require( './extapi.js' )->versionCheck( '^0.10.0' );
$temp0 = $ParsoidExtApi;
$ContentUtils = $temp0::ContentUtils;
$DOMDataUtils = $temp0::DOMDataUtils;
$DOMUtils = $temp0::DOMUtils;
$TokenUtils = $temp0::TokenUtils;
$WTUtils = $temp0::WTUtils;
$Promise = $temp0::Promise;

/**
 * @class
 */
class References {
	public static function hasRef( $node ) {
		$c = $node->firstChild;
		while ( $c ) {
			if ( DOMUtils::isElt( $c ) ) {
				if ( WTUtils::isSealedFragmentOfType( $c, 'ref' ) ) {
					return true;
				}
				if ( self::hasRef( $c ) ) {
					return true;
				}
			}
			$c = $c->nextSibling;
		}
		return false;
	}

	public static function toDOM( $state, $content, $args ) {
		return ParsoidExtApi::parseTokenContentsToDOM( $state, $args, '', $content, [
				'wrapperTag' => 'div',
				'extTag' => 'references',
				'inTemplate' => $state->parseContext->inTemplate
			]
		)->then( function ( $doc ) use ( &$TokenUtils, &$args, &$state ) {
				$refsOpts = Object::assign( [
						'group' => null,
						'responsive' => null
					], TokenUtils::kvToHash( $args, true )
				);

				$frag = References::createReferences( $state->env, $doc, $doc->body, $refsOpts, function ( $dp ) use ( &$state ) {
						$dp->src = ( $state->extToken->hasAttribute( 'source' ) ) ? $state->extToken->getAttribute( 'source' ) : null;
						// Redundant - also present on doc.body.firstChild, but feels cumbersome to use
						$dp->selfClose = $state->extToken->dataAttribs->selfClose;
				}
				);
				$doc->body->appendChild( $frag );

				return $doc;
		}
		);
	}

	public static function createReferences( $env, $doc, $body, $refsOpts, $modifyDp, $autoGenerated ) {
		$ol = $doc->createElement( 'ol' );
		$ol->classList->add( 'mw-references' );
		$ol->classList->add( 'references' );

		if ( $body ) {
			DOMUtils::migrateChildren( $body, $ol );
		}

		// Support the `responsive` parameter
		$rrOpts = $env->conf->wiki->responsiveReferences;
		$responsiveWrap = $rrOpts->enabled;
		if ( $refsOpts->responsive !== null ) {
			$responsiveWrap = $refsOpts->responsive !== '0';
		}

		$frag = null;
		if ( $responsiveWrap ) {
			$div = $doc->createElement( 'div' );
			$div->classList->add( 'mw-references-wrap' );
			$div->appendChild( $ol );
			$frag = $div;
		} else {
			$frag = $ol;
		}

		if ( $autoGenerated ) {
			DOMDataUtils::addAttributes( $frag, [
					'typeof' => 'mw:Extension/references',
					'about' => $env->newAboutId()
				]
			);
		}

		$dp = DOMDataUtils::getDataParsoid( $frag );
		if ( $refsOpts->group ) { // No group for the empty string either
			$dp->group = $refsOpts->group;
			$ol->setAttribute( 'data-mw-group', $refsOpts->group );
		}
		if ( gettype( $modifyDp ) === 'function' ) {
			$modifyDp( $dp );
		}

		return $frag;
	}

	public static function extractRefFromNode( $node, $refsData, $referencesAboutId, $referencesGroup, $nestedRefsHTML ) {
		$env = $refsData->env;
		$doc = $node->ownerDocument;
		$nestedInReferences = $referencesAboutId !== null;

		// This is data-parsoid from the dom fragment node that's gone through
		// dsr computation and template wrapping.
		$nodeDp = DOMDataUtils::getDataParsoid( $node );
		$typeOf = $node->getAttribute( 'typeof' ) || '';
		$isTplWrapper = preg_match( '/\bmw:Transclusion\b/', $typeOf );
		$nodeType = preg_replace( '/mw:DOMFragment\/sealed\/ref/', '', $typeOf, 1 );
		$content = $nodeDp->html;
		$tplDmw = ( $isTplWrapper ) ? DOMDataUtils::getDataMw( $node ) : null;

		// This is the <sup> that's the meat of the sealed fragment
		$c = $env->fragmentMap->get( $content )[ 0 ];
		// All the actions that require loaded data-attributes on `c` are done
		// here so that we can quickly store those away for later.
		DOMDataUtils::visitAndLoadDataAttribs( $c );
		$cDp = DOMDataUtils::getDataParsoid( $c );
		$refDmw = DOMDataUtils::getDataMw( $c );
		if ( !$cDp->empty && self::hasRef( $c ) ) { // nested ref-in-ref
			self::_processRefs( $env, $refsData, $c );
		}
		DOMDataUtils::visitAndStoreDataAttribs( $c );

		// Use the about attribute on the wrapper with priority, since it's
		// only added when the wrapper is a template sibling.
		$about = ( $node->hasAttribute( 'about' ) ) ? $node->getAttribute( 'about' ) :
		( $c->hasAttribute( 'about' ) ) ? $c->getAttribute( 'about' ) : '';

		// FIXME(SSS): Need to clarify semantics here.
		// If both the containing <references> elt as well as the nested <ref>
		// elt has a group attribute, what takes precedence?
		$group = $refDmw->attrs->group || $referencesGroup || '';
		$refName = $refDmw->attrs->name || '';
		$ref = $refsData->add( $env, $group, $refName, $about, $nestedInReferences );

		// Add ref-index linkback
		$linkBack = $doc->createElement( 'sup' );

		// FIXME: Lot of useless work for an edge case
		if ( $cDp->empty ) {
			// Discard wrapper if there was no input wikitext
			$content = null;
			if ( $cDp->selfClose ) {
				$refDmw->body = null;
			} else {
				$refDmw->body = [ 'html' => '' ];
			}
		} else {
			// If there are multiple <ref>s with the same name, but different content,
			// the content of the first <ref> shows up in the <references> section.
			// in order to ensure lossless RT-ing for later <refs>, we have to record
			// HTML inline for all of them.
			$html = '';
			$contentDiffers = false;
			if ( $ref->hasMultiples ) {
				// Use the non-pp version here since we've already stored attribs
				// before putting them in the map.
				$html = ContentUtils::toXML( $c, [ 'innerXML' => true ] );
				$contentDiffers = $html !== $ref->cachedHtml;
			}
			if ( $contentDiffers ) {
				$refDmw->body = [ 'html' => $html ];
			} else {
				$refDmw->body = [ 'id' => 'mw-reference-text-' . $ref->target ];
			}
		}

		DOMDataUtils::addAttributes( $linkBack, [
				'about' => $about,
				'class' => 'mw-ref',
				'id' => ( $nestedInReferences ) ? null :
				( ( $ref->name ) ? $ref->linkbacks[ count( $ref->linkbacks ) - 1 ] : $ref->id ),
				'rel' => 'dc:references',
				'typeof' => $nodeType
			]
		);
		DOMDataUtils::addTypeOf( $linkBack, 'mw:Extension/ref' );
		$dataParsoid = [
			'src' => $nodeDp->src,
			'dsr' => $nodeDp->dsr,
			'pi' => $nodeDp->pi
		];
		DOMDataUtils::setDataParsoid( $linkBack, $dataParsoid );
		if ( $isTplWrapper ) {
			DOMDataUtils::setDataMw( $linkBack, $tplDmw );
		} else {
			DOMDataUtils::setDataMw( $linkBack, $refDmw );
		}

		// refLink is the link to the citation
		$refLink = $doc->createElement( 'a' );
		DOMDataUtils::addAttributes( $refLink, [
				'href' => $env->page->titleURI . '#' . $ref->target,
				'style' => 'counter-reset: mw-Ref ' . $ref->groupIndex . ';'
			]
		);
		if ( $ref->group ) {
			$refLink->setAttribute( 'data-mw-group', $ref->group );
		}

		// refLink-span which will contain a default rendering of the cite link
		// for browsers that don't support counters
		$refLinkSpan = $doc->createElement( 'span' );
		$refLinkSpan->setAttribute( 'class', 'mw-reflink-text' );
		$refLinkSpan->appendChild( $doc->createTextNode( '['
. ( ( $ref->group ) ? $ref->group . ' ' : '' ) . $ref->groupIndex . ']'
			)
		);
		$refLink->appendChild( $refLinkSpan );
		$linkBack->appendChild( $refLink );

		if ( !$nestedInReferences ) {
			$node->parentNode->replaceChild( $linkBack, $node );
		} else {
			// We don't need to delete the node now since it'll be removed in
			// `insertReferencesIntoDOM` when all the children all cleaned out.
			array_push( $nestedRefsHTML, ContentUtils::ppToXML( $linkBack ), "\n" );
		}

		// Keep the first content to compare multiple <ref>s with the same name.
		if ( !$ref->content ) {
			$ref->content = $content;
			$ref->dir = strtolower( $refDmw->attrs->dir || '' );
		}
	}

	public static function insertReferencesIntoDOM( $refsNode, $refsData, $nestedRefsHTML, $autoGenerated ) {
		$env = $refsData->env;
		$isTplWrapper = preg_match( '/\bmw:Transclusion\b/', $refsNode->getAttribute( 'typeof' ) || '' );
		$dp = DOMDataUtils::getDataParsoid( $refsNode );
		$group = $dp->group || '';
		if ( !$isTplWrapper ) {
			$dataMw = DOMDataUtils::getDataMw( $refsNode );
			if ( !count( Object::keys( $dataMw ) ) ) {
				// FIXME: This can be moved to `insertMissingReferencesIntoDOM`
				Assert::invariant( $autoGenerated );
				$dataMw = [
					'name' => 'references',
					'attrs' => [
						'group' => $group || null
					]
				]; // Dont emit empty keys

				DOMDataUtils::setDataMw( $refsNode, $dataMw );
			}

			// Mark this auto-generated so that we can skip this during
			// html -> wt and so that clients can strip it if necessary.
			if ( $autoGenerated ) {
				$dataMw->autoGenerated = true;
			} elseif ( count( $nestedRefsHTML ) > 0 ) {
				$dataMw->body = [ 'html' => "\n" . implode( '', $nestedRefsHTML ) ];
			} elseif ( !$dp->selfClose ) {
				$dataMw->body = [ 'html' => '' ];
			} else {
				$dataMw->body = null;
			}
			$dp->selfClose = null;
		}

		$refGroup = $refsData->getRefGroup( $group );

		// Deal with responsive wrapper
		if ( $refsNode->classList->contains( 'mw-references-wrap' ) ) {
			$rrOpts = $env->conf->wiki->responsiveReferences;
			if ( $refGroup && count( $refGroup->refs ) > $rrOpts->threshold ) {
				$refsNode->classList->add( 'mw-references-columns' );
			}
			$refsNode = $refsNode->firstChild;
		}

		// Remove all children from the references node
		//
		// Ex: When {{Reflist}} is reused from the cache, it comes with
		// a bunch of references as well. We have to remove all those cached
		// references before generating fresh references.
		while ( $refsNode->firstChild ) {
			$refsNode->removeChild( $refsNode->firstChild );
		}

		if ( $refGroup ) {
			$refGroup->refs->forEach( function ( $ref ) use ( &$refGroup, &$env, &$refsNode ) {return $refGroup->renderLine( $env, $refsNode, $ref );
   } );
		}

		// Remove the group from refsData
		$refsData->removeRefGroup( $group );
	}

	/**
	 * Process `<ref>`s left behind after the DOM is fully processed.
	 * We process them as if there was an implicit `<references />` tag at
	 * the end of the DOM.
	 */
	public static function insertMissingReferencesIntoDOM( $refsData, $node ) {
		$env = $refsData->env;
		$doc = $node->ownerDocument;

		$refsData->refGroups->forEach( function ( $refsValue, $refsGroup ) use ( &$env, &$doc, &$node, &$refsData ) {
				$frag = References::createReferences( $env, $doc, null, [
						'group' => $refsGroup,
						'responsive' => null
					], function ( $dp ) {
						// The new references come out of "nowhere", so to make selser work
						// propertly, add a zero-sized DSR pointing to the end of the document.
						$dp->dsr = [ count( $env->page->src ), count( $env->page->src ), 0, 0 ];
					}, true
				);

				// Add a \n before the <ol> so that when serialized to wikitext,
				// each <references /> tag appears on its own line.
				$node->appendChild( $doc->createTextNode( "\n" ) );
				$node->appendChild( $frag );

				References::insertReferencesIntoDOM( $frag, $refsData, [ '' ], true );
		}
		);
	}

	public static function lintHandler( $refs, $env, $tplInfo, $domLinter ) {
		// Nothing to do
		//
		// FIXME: Not entirely true for scenarios where the <ref> tags
		// are defined in the references section that is itself templated.
		//
		// {{1x|<references>\n<ref name='x'><b>foo</ref>\n</references>}}
		//
		// In this example, the references tag has the right tplInfo and
		// when the <ref> tag is processed in the body of the article where
		// it is accessed, there is no relevant template or dsr info available.
		//
		// Ignoring for now.
		return $refs->nextNode;
	}

	public static function _processRefs( $env, $refsData, $node ) {
		$child = $node->firstChild;
		while ( $child !== null ) {
			$nextChild = $child->nextSibling;
			if ( DOMUtils::isElt( $child ) ) {
				if ( WTUtils::isSealedFragmentOfType( $child, 'ref' ) ) {
					self::extractRefFromNode( $child, $refsData );
				} elseif ( preg_match( ( '/(?:^|\s)mw:Extension\/references(?=$|\s)/' ), $child->getAttribute( 'typeOf' ) || '' ) ) {
					$referencesId = $child->getAttribute( 'about' ) || '';
					$referencesGroup = DOMDataUtils::getDataParsoid( $child )->group;
					$nestedRefsHTML = [];
					self::_processRefsInReferences( $refsData, $child, $referencesId, $referencesGroup, $nestedRefsHTML );
					self::insertReferencesIntoDOM( $child, $refsData, $nestedRefsHTML );
				} else {
					// inline media -- look inside the data-mw attribute
					if ( WTUtils::isInlineMedia( $child ) ) {
						/* -----------------------------------------------------------------
						 * FIXME(subbu): This works but feels very special-cased in 2 ways:
						 *
						 * 1. special cased to images vs. any node that might have
						 *    serialized HTML embedded in data-mw
						 * 2. special cased to global cite handling -- the general scenario
						 *    is DOM post-processors that do different things on the
						 *    top-level vs not.
						 *    - Cite needs to process these fragments in the context of the
						 *      top-level page, and has to be done in order of how the nodes
						 *      are encountered.
						 *    - DOM cleanup can be done on embedded fragments without
						 *      any page-level context and in any order.
						 *    - So, some variability here.
						 *
						 * We should be running dom.cleanup.js passes on embedded html
						 * in data-mw and other attributes. Since correctness doesn't
						 * depend on that cleanup, I am not adding more special-case
						 * code in dom.cleanup.js.
						 *
						 * Doing this more generically will require creating a DOMProcessor
						 * class and adding state to it.
						 *
						 * See T214994
						 * ----------------------------------------------------------------- */
						$dmw = DOMDataUtils::getDataMw( $child );
						$caption = $dmw->caption;
						if ( $caption ) {
							// Extract the caption HTML, build the DOM, process refs,
							// serialize to HTML, update the caption HTML.
							$captionDOM = ContentUtils::ppToDOM( $env, $caption );
							self::_processRefs( $env, $refsData, $captionDOM );
							$dmw->caption = ContentUtils::ppToXML( $captionDOM, [ 'innerXML' => true ] );
						}
					}
					if ( $child->hasChildNodes() ) {
						self::_processRefs( $env, $refsData, $child );
					}
				}
			}
			$child = $nextChild;
		}
	}

	/**
	 * This handles wikitext like this:
	 * ```
	 *   <references> <ref>foo</ref> </references>
	 *   <references> <ref>bar</ref> </references>
	 * ```
	 * @private
	 */
	public static function _processRefsInReferences( $refsData, $node, $referencesId, $referencesGroup, $nestedRefsHTML ) {
		$child = $node->firstChild;
		while ( $child !== null ) {
			$nextChild = $child->nextSibling;
			if ( DOMUtils::isElt( $child ) ) {
				if ( WTUtils::isSealedFragmentOfType( $child, 'ref' ) ) {
					self::extractRefFromNode( $child, $refsData, $referencesId, $referencesGroup, $nestedRefsHTML );
				} elseif ( $child->hasChildNodes() ) {
					self::_processRefsInReferences( $refsData, $child, $referencesId, $referencesGroup, $nestedRefsHTML );
				}
			}
			$child = $nextChild;
		}
	}
}

References::serialHandler = [
	'handle' => /* async */function ( $node, $state, $wrapperUnmodified ) use ( &$DOMDataUtils ) {
		$dataMw = DOMDataUtils::getDataMw( $node );
		if ( $dataMw->autoGenerated && $state->rtTestMode ) {
			// Eliminate auto-inserted <references /> noise in rt-testing
			return '';
		} else {
			$startTagSrc = /* await */ $state->serializer->serializeExtensionStartTag( $node, $state );
			if ( !$dataMw->body ) {
				return $startTagSrc; // We self-closed this already.
			} else { // We self-closed this already.
			if ( gettype( $dataMw->body->html ) === 'string' ) {
				$src = /* await */ $state->serializer->serializeHTML( [
						'env' => $state->env,
						'extName' => $dataMw->name
					], $dataMw->body->html
				);
				return $startTagSrc + $src . '</' . $dataMw->name . '>';
			} else {
				$state->env->log( 'error',
					'References body unavailable for: ' . $node->outerHTML
				);
				return ''; // Drop it!
			}
			}
		}
	}

	, // Drop it!

	// FIXME: LEAKY -- Should we expose newline constraints to extensions?
	'before' => function ( $node, $otherNode, $state ) use ( &$WTUtils ) {
		// Serialize new references tags on a new line.
		if ( WTUtils::isNewElt( $node ) ) {
			return [ 'min' => 1, 'max' => 2 ];
		} else {
			return null;
		}
	}
];

$module->exports = $References;
